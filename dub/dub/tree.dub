struct TextMatch {
}

struct RuneFilter {
  Min rune
  Max rune
}

struct RuneRangeMatch implements TextMatch {
  Invert bool
  Filters []RuneFilter
}

struct StringLiteralMatch implements TextMatch {
  Value string
}

struct MatchSequence implements TextMatch {
  Matches []TextMatch
}

struct MatchChoice implements TextMatch {
  Matches []TextMatch
}

struct MatchRepeat implements TextMatch {
  Match TextMatch
  Min int
}

struct MatchLookahead implements TextMatch {
  Invert bool
  Match TextMatch
}

struct Id {
       Pos int
       Text string
}

struct ASTExpr {
}

struct RuneLiteral implements ASTExpr {
  Text string
  Value rune
}

struct StringLiteral implements ASTExpr {
  Text string
  Value string
}

struct IntLiteral implements ASTExpr {
  Text string
  Value int
}

struct BoolLiteral implements ASTExpr {
  Text string
  Value bool
}

struct NilLiteral implements ASTExpr {
}

func LineTerminator() {
  /"\n"|"\r\n"|"\r"/;
}

func S() {
  star {
    choose {
      /[ \t]/;
    } or {
      LineTerminator();
    } or {
      /"//" [^\n\r]*/;
    }
  }
}

func EndKeyword() {
  /![a-zA-Z_0-9]/;
}

func Ident() Id {
  p := position;
  // Don't allow keywords as identifiers.
  /!(("func"|"test"|"struct"|"star"|"plus"|"choose"|"or"|"question"|"if"|"else"|"true"|"false"|"nil") ![a-zA-Z_0-9])/;
  text := /[a-zA-Z_][a-zA-Z_0-9]*/;
  return Id{Pos: p, Text: text};
}

func DecodeInt() (int, string) {
    var value int;
    text := slice {
      plus {
        digit := coerce(int, $[0-9]) - coerce(int, '0');
        value = value * 10 + digit;
      }
    };
    return value, text;
}

func EscapedChar() rune {
  choose {
    /[a]/;
    return '\a';
  } or {
    /[b]/;
    return '\b';
  } or {
    /[f]/;
    return '\f';
  } or {
    /[n]/;
    return '\n';
  } or {
    /[r]/;
    return '\r';
  } or {
    /[t]/;
    return '\t';
  } or {
    /[v]/;
    return '\v';
  } or {
    /[\\]/;
    return '\\';
  } or {
    /[']/;
    return '\'';
  } or {
    /["]/;
    return '"';
  }
}

func DecodeString() string {
  /["]/;
  contents := []rune{};
  star {
    choose {
      append(contents, $[^"\\]);
    } or {
      /[\\]/;
      append(contents, EscapedChar());
    }
  }
  /["]/;
  return coerce(string, contents);
}

func DecodeRune() (rune, string) {
  var value rune;
  text := slice {
    /[']/;
    choose {
      value = $[^\\'];
    } or {
      /[\\]/;
      value = EscapedChar();
    }
    /[']/;
  };
  return value, text;
}

func DecodeBool() (bool, string) {
  var value bool;
  text := slice {
    choose {
      /"true"/;
      value = true;
    } or {
      /"false"/;
      value = false;
    }
    EndKeyword();
  };
  return value, text;
}

func Literal() ASTExpr {
  choose {
    value, text := DecodeRune();
    return RuneLiteral{Text: text, Value: value};
  } or {
    var value string;
    text := slice {
      value = DecodeString();
    };
    return StringLiteral{Text: text, Value: value};
  } or {
    value, text := DecodeInt();
    return IntLiteral{Text: text, Value: value};
  } or {
    value, text := DecodeBool();
    return BoolLiteral{Text: text, Value: value};
  } or {
    /"nil"/;
    return NilLiteral{};
  }
}

func BinaryOperator() (string, int) {
  var op string;
  var prec int;
  choose {
    return /[*/%]/, 5;
  } or {
    return /[+\-]/, 4;
  } or {
    return /([<>][=]?)|([!=][=])/, 3;
  }
}


struct StringMatch implements ASTExpr {
   Match TextMatch
}

struct RuneMatch implements ASTExpr {
   Match RuneRangeMatch
}

func StringMatchExpr() StringMatch {
  /[/]/;
  S();
  e := ParseMatchChoice();
  S();
  /[/]/;
  return StringMatch{Match: e};
}

func RuneMatchExpr() RuneMatch {
  /[$]/;
  S();
  e := MatchRune();
  return RuneMatch{Match: e};
}


test Alpha Ident() "a_B_c"
  Id{Text: "a_B_c"}

test AlphaNum Ident() "a_1_7"
  Id{Text: "a_1_7"}

test Num Literal() "1234567890"
  IntLiteral{
    Text: "1234567890"
    Value: 1234567890
 }

test Str Literal() "\"hello, world\\n\""
  StringLiteral{
    Text: "\"hello, world\\n\""
    Value: "hello, world\n"
  }

test Rune Literal() "'a'"
  RuneLiteral{
    Text: "'a'"
    Value: 'a'
  }

test EscapedRune Literal() "'\\n'"
  RuneLiteral{
    Text: "'\\n'"
    Value: '\n'
  }

test True Literal() "true"
  BoolLiteral{
    Text: "true"
    Value: true
  }

test False Literal() "false"
  BoolLiteral{
    Text: "false"
    Value: false
  }

test Nil Literal() "nil"
  NilLiteral{}

struct ASTDecl {
}

struct ASTType implements ASTDecl {
}

struct ASTTypeRef {
}

struct TypeRef implements ASTTypeRef {
  Name Id
  T ASTType
}

struct ListTypeRef implements ASTTypeRef {
  Type ASTTypeRef
  T ASTType
}

func ParseStructTypeRef() TypeRef {
    return TypeRef{Name: Ident()};
}

func ParseListTypeRef() ListTypeRef {
    /[\[][\]]/;
    return ListTypeRef{Type: ParseTypeRef()};
}


func ParseTypeRef() ASTTypeRef {
  choose {
    return ParseStructTypeRef();
  } or {
    return ParseListTypeRef();
  }
}

test ListOfList ParseTypeRef() "[][]Foo"
  ListTypeRef{
    Type: ListTypeRef{
      Type: TypeRef{
        Name: Id{Text: "Foo"}
      }
    }
  }

struct Destructure {
}

struct DestructureValue implements Destructure {
  Expr ASTExpr
}

struct DestructureField {
  Name Id
  Destructure Destructure
}

struct DestructureStruct implements Destructure {
  Type TypeRef
  Args []DestructureField
}

struct DestructureList implements Destructure {
  Type ListTypeRef
  Args []Destructure
}

func ParseDestructure() Destructure {
  choose {
    t := ParseStructTypeRef();
    S();
    /[{]/;
    S();
    fields := []DestructureField{};
    star {
      name := Ident();
      S();
      /[:]/;
      S();
      d := ParseDestructure();
      S();
      append(fields, DestructureField{Name: name, Destructure: d});
    }
    /[}]/;
    return DestructureStruct{Type: t, Args: fields};
  } or {
    t := ParseListTypeRef();
    S();
    /[{]/;
    S();
    fields := []Destructure{};
    star {
      append(fields, ParseDestructure());
      S();
    }
    /[}]/;
    return DestructureList{Type: t, Args: fields};
  } or {
    return DestructureValue{Expr: Literal()};
  }
}

test Compound ParseDestructure() "[]Foo { Bar { Baz: 1 Biz : 'x'} }"
  DestructureList {
    Type: ListTypeRef {
      Type: TypeRef {
        Name: Id{Text: "Foo"}
      }
    }
    Args: []Destructure {
      DestructureStruct {
        Type: TypeRef {
          Name: Id{Text: "Bar"}
        }
        Args: []DestructureField {
          DestructureField {
            Name: Id{Text: "Baz"}
            Destructure: DestructureValue {
              Expr: IntLiteral {
                Value: 1
              }
            }
          }
          DestructureField {
            Name: Id{Text: "Biz"}
            Destructure: DestructureValue {
              Expr: RuneLiteral {
                Value: 'x'
              }
            }
          }
        }
      }
    }
  }

func ParseRuneFilterRune() rune {
  choose {
    return $[^\]\-\\];
  } or {
    /[\\]/;
    choose {
      return EscapedChar();
    } or {
      return $[^];
    }
  }
}

func ParseRuneFilter() RuneFilter {
  min := ParseRuneFilterRune();
  max := min;
  question {
    /[\-]/;
    max = ParseRuneFilterRune();
  }
  return RuneFilter{Min: min, Max: max};
}

func MatchRune() RuneRangeMatch {
  /[\[]/;
  invert := false;
  filters := []RuneFilter{};
  question {
    /[\^]/;
    invert = true;
  }
  star {
    append(filters, ParseRuneFilter());
  }
  /[\]]/;
  return RuneRangeMatch{Invert: invert, Filters: filters};
}

func Atom() TextMatch {
  choose {
    return MatchRune();
  } or {
    value := DecodeString();
    return StringLiteralMatch{Value: value};
  } or {
    /[(]/;
    S();
    e := ParseMatchChoice();
    S();
    /[)]/;
    return e;
  }
}

func MatchPostfix() TextMatch {
  e := Atom();
  choose {
    S();
    /[*]/;
    return MatchRepeat{Match: e, Min: 0};
  } or {
    S();
    /[+]/;
    return MatchRepeat{Match: e, Min: 1};
  } or {
    S();
    /[?]/;
    return MatchChoice{Matches: []TextMatch{e, MatchSequence{Matches: []TextMatch{}}}};
  } or {
    return e;
  }
}

func MatchPrefix() TextMatch {
  choose {
    var invert bool;
    choose {
      /[!]/;
      invert = true;
    } or {
      /[&]/;
    }
    S();
    return MatchLookahead{Invert: invert, Match: MatchPostfix()};
  } or {
    return MatchPostfix();
  }
}

func Sequence() TextMatch {
  e := MatchPrefix();
  choose {
    l := []TextMatch{e};
    plus {
      S();
      append(l, MatchPrefix());
    }
    return MatchSequence{Matches: l};
  } or {
    return e;
  }
}

func ParseMatchChoice() TextMatch {
  e := Sequence();
  choose {
    l := []TextMatch{e};
    plus {
      S();
      /[|]/;
      S();
      append(l, Sequence());
    }
    return MatchChoice{Matches: l};
  } or {
    return e;
  }
}


test One ParseMatchChoice() "[pq]"
  RuneRangeMatch {
    Invert: false
    Filters: []RuneFilter {
      RuneFilter {
        Min: 'p'
        Max: 'p'
      }
      RuneFilter {
        Min: 'q'
        Max: 'q'
      }
    }
  }

test Invert ParseMatchChoice() "[^.]"
  RuneRangeMatch {
    Invert: true
    Filters: []RuneFilter {
      RuneFilter {
        Min: '.'
        Max: '.'
      }
    }
  }

test Escape ParseMatchChoice() "[\\]\\n]"
  RuneRangeMatch {
    Filters: []RuneFilter {
      RuneFilter {
        Min: ']'
        Max: ']'
      }
      RuneFilter {
        Min: '\n'
        Max: '\n'
      }
    }
  }


test Three ParseMatchChoice() "[a][b][c]"
  MatchSequence {
    Matches: []TextMatch {
      RuneRangeMatch {
        Filters: []RuneFilter {
          RuneFilter {
            Min: 'a'
            Max: 'a'
          }
        }
      }
      RuneRangeMatch {
        Filters: []RuneFilter {
          RuneFilter {
            Min: 'b'
            Max: 'b'
          }
        }
      }
      RuneRangeMatch {
        Filters: []RuneFilter {
          RuneFilter {
            Min: 'c'
            Max: 'c'
          }
        }
      }
    }
  }

test Repeat ParseMatchChoice() "[0-9] +"
  MatchRepeat {
    Match: RuneRangeMatch {
      Filters: []RuneFilter {
        RuneFilter {
          Min: '0'
          Max: '9'
        }
      }
    }
    Min: 1
  }

test Question ParseMatchChoice() "[*]?"
  MatchChoice {
    Matches: []TextMatch {
      RuneRangeMatch {
        Filters: []RuneFilter {
          RuneFilter {
            Min: '*'
            Max: '*'
          }
        }
      }
      MatchSequence {
        Matches: []TextMatch{}
      }
    }
  }

test Complex ParseMatchChoice() "[a] ( [b]|[c] ) | [d]"
  MatchChoice {
    Matches: []TextMatch {
      MatchSequence {
        Matches: []TextMatch{
          RuneRangeMatch {
            Filters: []RuneFilter {
              RuneFilter {
                Min: 'a'
                Max: 'a'
               }
            }
          }
          MatchChoice {
            Matches: []TextMatch {
              RuneRangeMatch {
                Filters: []RuneFilter {
                  RuneFilter {
                    Min: 'b'
                    Max: 'b'
                  }
                }
              }
              RuneRangeMatch {
                Filters: []RuneFilter {
                  RuneFilter {
                    Min: 'c'
                    Max: 'c'
                  }
                }
              }
            }
          }
        }
      }
      RuneRangeMatch {
        Filters: []RuneFilter {
          RuneFilter {
            Min: 'd'
            Max: 'd'
          }
        }
      }
    }
  }

test PositiveLookahead ParseMatchChoice() "&[.]"
  MatchLookahead {
    Invert: false
    Match: RuneRangeMatch {
      Invert: false
      Filters: []RuneFilter {
        RuneFilter {
          Min: '.'
          Max: '.'
        }
      }
    }
  }

test NegativeLookahead ParseMatchChoice() "![.]"
  MatchLookahead {
    Invert: true
    Match: RuneRangeMatch {
      Invert: false
      Filters: []RuneFilter {
        RuneFilter {
          Min: '.'
          Max: '.'
        }
      }
    }
  }


struct If implements ASTExpr {
  Expr ASTExpr
  Block []ASTExpr
}

struct Repeat implements ASTExpr {
  Block []ASTExpr
  Min int
}

struct Choice implements ASTExpr {
  Blocks [][]ASTExpr
}

struct Optional implements ASTExpr {
  Block []ASTExpr
}

struct Slice implements ASTExpr {
  Block []ASTExpr
}

struct Assign implements ASTExpr {
  Expr ASTExpr
  Targets []ASTExpr
  Type ASTTypeRef
  Define bool
}

struct NameRef implements ASTExpr {
  Name Id
  Local LocalInfo
}

struct NamedExpr {
  Name Id
  Expr ASTExpr
}

struct Construct implements ASTExpr {
  Type TypeRef
  Args []NamedExpr
}

struct ConstructList implements ASTExpr {
  Type ListTypeRef
  Args []ASTExpr
}

struct Coerce implements ASTExpr {
  Type ASTTypeRef
  Expr ASTExpr
}

struct Call implements ASTExpr {
  Name Id
  Args []ASTExpr
  Target ASTCallable
  T []ASTType
}

struct Position implements ASTExpr {
}

struct Fail implements ASTExpr {
}

struct Append implements ASTExpr {
  List ASTExpr
  Expr ASTExpr
  T ASTType
}

struct Return implements ASTExpr {
  Exprs []ASTExpr
}

struct BinaryOp implements ASTExpr {
  Left ASTExpr
  Op string
  Right ASTExpr
  T ASTType
}

func ParseExprList() []ASTExpr {
  exprs := []ASTExpr{};
  question {
    append(exprs, ParseExpr());
    star {
      S();
      /[,]/;
      S();
      append(exprs, ParseExpr());
    }
  }
  return exprs;
}

func ParseTargetList() []ASTExpr {
  exprs := []ASTExpr{ParseNameRef()};
  star {
    S();
    /[,]/;
    S();
    append(exprs, ParseNameRef());
  }
  return exprs;
}

func ParseNamedExpr() NamedExpr {
  name := Ident();
  S();
  /[:]/;
  S();
  return NamedExpr{Name: name, Expr: ParseExpr()};
}

func ParseNamedExprList() []NamedExpr {
  exprs := []NamedExpr{};
  question {
    append(exprs, ParseNamedExpr());
    star {
      S();
      /[,]/;
      S();
      append(exprs, ParseNamedExpr());
    }
  }
  return exprs;
}


func ParseReturnTypeList() []ASTTypeRef {
  choose {
    return ParseParenthTypeList();
  } or {
    return []ASTTypeRef{ParseTypeRef()};
  } or {
    return []ASTTypeRef{};
  }
}

func PrimaryExpr() ASTExpr {
  choose {
    return Literal();
  } or {
    // Slice is currently the only expression containing a code block.
    /"slice"/;
    EndKeyword();
    S();
    block := ParseCodeBlock();
    return Slice{Block: block};
  } or {
    /"position"/;
    EndKeyword();
    return Position{};
  } or {
    /"coerce"/;
    EndKeyword();
    S();
    /[(]/;
    S();
    t := ParseTypeRef();
    S();
    /[,]/;
    S();
    e := ParseExpr();
    S();
    /[)]/;
    return Coerce{Type: t, Expr: e};
  } or {
    /"append"/;
    EndKeyword();
    S();
    /[(]/;
    S();
    name := Ident();
    S();
    /[,]/;
    S();
    expr := ParseExpr();
    S();
    /[)]/;
    // TODO make the copy of the name node explicit?
    return Assign{
      Expr: Append{
        List: NameRef{Name: name},
        Expr: expr
      },
      Targets: []ASTExpr{NameRef{Name: name}}
    };
  } or {
    name := Ident();
    S();
    /[(]/;
    S();
    args := ParseExprList();
    S();
    /[)]/;
    return Call{Name: name, Args: args};
  } or {
    t := ParseStructTypeRef();
    S();
    /[{]/;
    S();
    args := ParseNamedExprList();
    S();
    /[}]/;
    return Construct{Type: t, Args: args};
  } or {
    t := ParseListTypeRef();
    S();
    /[{]/;
    S();
    args := ParseExprList();
    S();
    /[}]/;
    return ConstructList{Type: t, Args: args};
  } or {
    return StringMatchExpr();
  } or {
    return RuneMatchExpr();
  } or {
    /[(]/;
    S();
    e := ParseExpr();
    S();
    /[)]/;
    return e;
  } or {
    return ParseNameRef();
  }
}

func ParseNameRef() NameRef {
    // TODO supress keywords.
    return NameRef{Name: Ident()};
}

test SimpleName ParseNameRef() "foobar"
  NameRef {
    Name: Id {
      Text: "foobar"
    }
  }

test PartKeyword ParseNameRef() "trueish"
  NameRef {
    Name: Id {
      Text: "trueish"
    }
  }

test RejectKeyword ParseNameRef() "true"
  FAIL
  nil

// Uses precedence climbing.
func ParseBinaryOp(min_prec int) ASTExpr {
  e := PrimaryExpr();
  star {
    S();
    // TODO associativity
    op, prec := BinaryOperator();
    if prec < min_prec {
      fail;
    }
    S();
    r := ParseBinaryOp(prec + 1);
    e = BinaryOp{Left: e, Op: op, Right: r};
  }
  return e;
}

func ParseExpr() ASTExpr {
     return ParseBinaryOp(1);
}

func ParseCompoundStatement() ASTExpr {
  choose {
    /"star"/;
    EndKeyword();
    S();
    block := ParseCodeBlock();
    return Repeat{Block: block, Min: 0};
  } or {
    /"plus"/;
    EndKeyword();
    S();
    block := ParseCodeBlock();
    return Repeat{Block: block, Min: 1};
  } or {
    /"choose"/;
    EndKeyword();
    S();
    blocks := [][]ASTExpr{ParseCodeBlock()};
    plus {
      S();
      /"or"/;
      EndKeyword();
      S();
      append(blocks, ParseCodeBlock());
    }
    return Choice{Blocks: blocks};
  } or {
    /"question"/;
    EndKeyword();
    S();
    block := ParseCodeBlock();
    return Optional{Block: block};
  } or {
    /"if"/;
    EndKeyword();
    S();
    expr := ParseExpr();
    S();
    block := ParseCodeBlock();
    return If{Expr: expr, Block: block};
  }
}

func EOS() {
  S();
  /[;]/;
}

func ParseStatement() ASTExpr {
  choose {
    return ParseCompoundStatement();
  } or {
    /"var"/;
    EndKeyword();
    S();
    name := ParseNameRef();
    S();
    t := ParseTypeRef();
    var expr ASTExpr;
    question {
      S();
      /[=]/;
      S();
      expr = ParseExpr(); 
    }
    EOS();
    return Assign{Expr: expr, Targets: []ASTExpr{name}, Type: t, Define: true};
  } or {
    /"fail"/;
    EndKeyword();
    EOS();
    return Fail{};
  } or {
    /"return"/;
    EndKeyword();
    S();
    exprs := ParseExprList();
    EOS();
    return Return{Exprs: exprs};
  } or {
    names := ParseTargetList();
    S();
    var defined bool;
    choose {
      /":="/;
      defined = true;
    } or {
      /"="/;
    }
    S();
    expr := ParseExpr();
    EOS();
    return Assign{Expr: expr, Targets: names, Define: defined};
  } or {
    e := ParseExpr();
    EOS();
    return e;
  }
}

func ParseCodeBlock() []ASTExpr {
  /[{]/;
  S();
  exprs := []ASTExpr{};
  star {
    append(exprs, ParseStatement());
    S();
  }
  /[}]/;
  return exprs;
}

test BinaryOpLeft ParseExpr() "12 + 34 - 56"
  BinaryOp {
    Left: BinaryOp {
      Left: IntLiteral {
        Value: 12
      }
      Op: "+"
      Right: IntLiteral {
        Value: 34
      }
    }
    Op: "-"
    Right: IntLiteral {
      Value: 56
    }
  }

test BinaryOpRight ParseExpr() "12 + (34 - 56)"
  BinaryOp {
    Left: IntLiteral {
      Value: 12
    }
    Op: "+"
    Right: BinaryOp {
      Left: IntLiteral {
        Value: 34
      }
      Op: "-"
      Right: IntLiteral {
        Value: 56
      }
    }
  }

test BinaryOpPrecLeft ParseExpr() "12 * 34 + 56"
  BinaryOp {
    Left: BinaryOp {
      Left: IntLiteral {
        Value: 12
      }
      Op: "*"
      Right: IntLiteral {
        Value: 34
      }
    }
    Op: "+"
    Right: IntLiteral {
      Value: 56
    }
  }

test BinaryOpPrecRight ParseExpr() "12 + 34 * 56"
  BinaryOp {
    Left: IntLiteral {
      Value: 12
    }
    Op: "+"
    Right: BinaryOp {
      Left: IntLiteral {
        Value: 34
      }
      Op: "*"
      Right: IntLiteral {
        Value: 56
      }
    }
  }

test Assign ParseStatement() "foo = 1;"
  Assign {
    Expr: IntLiteral {
      Value: 1
    }
    Targets: []ASTExpr{NameRef{Name: Id{Text: "foo"}}}
    Type: nil
    Define: false
  }

test Lookahead ParseStatement() "returnType = 1;"
  Assign {
    Expr: IntLiteral {
      Value: 1
    }
    Targets: []ASTExpr{NameRef{Name: Id{Text: "returnType"}}}
    Type: nil
    Define: false
  }

test Define ParseStatement() "foo := 1;"
  Assign {
    Expr: IntLiteral {
      Value: 1
    }
    Targets: []ASTExpr{NameRef{Name: Id{Text: "foo"}}}
    Type: nil
    Define: true
  }

test VarDecl ParseStatement() "var foo int = 1;"
  Assign {
    Expr: IntLiteral {
      Value: 1
    }
    Targets: []ASTExpr{NameRef{Name: Id{Text: "foo"}}}
    Type: TypeRef {
      Name: Id {
        Text: "int"
      }
    }
    Define: true
  }


test MultiAssign ParseStatement() "a, b, c = foo();"
  Assign {
    Expr: Call {
      Name: Id{Text: "foo"}
    }
    Targets: []ASTExpr{
      NameRef{Name: Id{Text: "a"}}
      NameRef{Name: Id{Text: "b"}}
      NameRef{Name: Id{Text: "c"}}
    }
    Define: false
  }

test MultiCall ParseStatement() "foo(a, b, c);"
  Call {
    Name: Id{Text: "foo"}
    Args: []ASTExpr{
      NameRef{Name: Id{Text: "a"}}
      NameRef{Name: Id{Text: "b"}}
      NameRef{Name: Id{Text: "c"}}
    }
  }


test Construct ParseExpr() "Foo{ Bar: 1}"
  Construct {
    Type: TypeRef {
      Name: Id{Text: "Foo"}
    }
    Args: []NamedExpr {
      NamedExpr{
        Name: Id{Text: "Bar"}
        Expr: IntLiteral {
          Value: 1
        }
      }
    }
  }

test ConstructList ParseExpr() "[]Foo{ 1 }"
  ConstructList {
    Type: ListTypeRef{
      Type: TypeRef {
        Name: Id{Text: "Foo"}
      }
    }
    Args: []ASTExpr {
      IntLiteral {
        Value: 1
      }
    }
  }

test Slice ParseStatement() "a := slice { 1; } ;"
  Assign {
    Expr: Slice{
      Block: []ASTExpr{
        IntLiteral {
          Value: 1
        }
      }
    }
    Targets: []ASTExpr{NameRef{Name: Id{Text: "a"}}}
    Define: true
  }

struct BuiltinType implements ASTType {
  Name string
}

struct NilType implements ASTType {
}

struct ListType implements ASTType {
  Type ASTType
}

struct FieldDecl {
  Name Id
  Type ASTTypeRef
}

struct StructDecl implements ASTType {
  Name Id
  Implements ASTTypeRef
  Fields []FieldDecl
  Scoped bool
  Contains []ASTTypeRef
}

func ParseParenthTypeList() []ASTTypeRef {
  /[(]/;
  S();
  types := []ASTTypeRef{};
  question {
    append(types, ParseTypeRef());
    S();
    star {
      /[,]/;
      S();
      append(types, ParseTypeRef());
      S();
    }
  }
  /[)]/;
  return types;
}

func ParseStructDecl() StructDecl {
  /"struct"/;
  EndKeyword();
  S();
  name := Ident();
  S();

  scoped := false;
  question {
    /"scoped"/;
    EndKeyword();
    S();
    scoped = true;
  }

  contains := []ASTTypeRef{};
  question {
    /"contains"/;
    EndKeyword();
    S();
    contains = ParseParenthTypeList();
    S();
  }

  var implements ASTTypeRef;
  question {
    /"implements"/;
    EndKeyword();
    S();
    implements = ParseTypeRef();
    S();
  }

  /[{]/;
  S();
  fields := []FieldDecl{};
  star {
    fn := Ident();
    S();
    ft := ParseTypeRef();
    S();
    append(fields, FieldDecl{Name: fn, Type: ft});
  }
  /[}]/;
  return StructDecl{
    Name: name,
    Implements: implements,
    Fields: fields,
    Scoped: scoped,
    Contains: contains
  };
}

struct ASTCallable implements ASTDecl {
}

struct LocalInfo scoped {
  Name string
  T ASTType
}

struct Param {
       Name NameRef
       Type ASTTypeRef
}

struct FuncDecl contains(LocalInfo) implements ASTCallable {
  Name Id
  Params []Param
  ReturnTypes []ASTTypeRef
  Block []ASTExpr
}

func ParseParam() Param {
     name := ParseNameRef();
     S();
     type := ParseTypeRef();
     return Param{Name: name, Type: type};
}

func ParseParamList() []Param {
  params := []Param{};
  question {
    append(params, ParseParam());
    star {
      S();
      /[,]/;
      S();
      append(params, ParseParam());
    }
  }
  return params;
}

func ParseFuncDecl() FuncDecl {
  /"func"/;
  EndKeyword();
  S();
  name := Ident();
  S();
  /"("/;
  S();
  params := ParseParamList();
  S();
  /")"/;
  S();
  retTypes := ParseReturnTypeList();
  S();
  block := ParseCodeBlock();
  return FuncDecl{Name: name, Params: params, ReturnTypes: retTypes, Block: block};
}

struct Test {
  Name Id
  Rule ASTExpr
  Type ASTType
  Input string
  Flow string // TODO enum
  Destructure Destructure
}

func ParseMatchState() string {
  choose {
    text := /"NORMAL"|"FAIL"/;
    EndKeyword();
    return text;
  } or {
    return "NORMAL";
  }
}

func ParseTest() Test {
  /"test"/;
  EndKeyword();
  S();
  name := Ident();
  S();
  rule := ParseExpr();
  S();
  input := DecodeString();
  S();
  flow := ParseMatchState();
  S();
  d := ParseDestructure();
  return Test{Name: name, Rule: rule, Input: input, Flow: flow, Destructure: d};
}

struct File {
  Decls []ASTDecl
  Tests []Test
}

func ParseFile() File {
  decls := []ASTDecl{};
  tests := []Test{};
  S();
  star {
    choose {
      append(decls, ParseFuncDecl());
    } or {
      append(decls, ParseStructDecl());
    } or {
      append(tests, ParseTest());
    }
    S();
  }
  /![^]/;
  return File{Decls: decls, Tests: tests};
}

struct Package {
  Path []string
  Files []File
}
