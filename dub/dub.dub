struct TextMatch {
}

struct RuneFilter {
  Min rune
  Max rune
}

struct RuneRangeMatch implements TextMatch {
  Invert bool
  Filters []RuneFilter
}

struct StringLiteralMatch implements TextMatch {
  Value string
}

struct MatchSequence implements TextMatch {
  Matches []TextMatch
}

struct MatchChoice implements TextMatch {
  Matches []TextMatch
}

struct MatchRepeat implements TextMatch {
  Match TextMatch
  Min int
}

struct MatchLookahead implements TextMatch {
  Invert bool
  Match TextMatch
}

struct Id {
       Pos int
       Text string
}

struct ASTExpr {
}

struct RuneLiteral implements ASTExpr {
  Text string
  Value rune
}

struct StringLiteral implements ASTExpr {
  Text string
  Value string
}

struct IntLiteral implements ASTExpr {
  Text string
  Value int
}

struct BoolLiteral implements ASTExpr {
  Text string
  Value bool
}

func S () {
  /[ \t\r\n]*/;
}

func EndKeyword () {
  /![a-zA-Z_0-9]/;
}

func Ident (Id) {
  p := position;
  text := /[a-zA-Z_][a-zA-Z_0-9]*/;
  return Id{Pos: p, Text: text};
}

func DecodeInt (int) {
    var value int;
    plus {
      digit := coerce(int, $[0-9]) - coerce(int, '0');
      value = value * 10 + digit;
    }
    return value;
}

func EscapedChar (rune) {
  choose {
    /[a]/;
    return '\a';
  } or {
    /[b]/;
    return '\b';
  } or {
    /[f]/;
    return '\f';
  } or {
    /[n]/;
    return '\n';
  } or {
    /[r]/;
    return '\r';
  } or {
    /[t]/;
    return '\t';
  } or {
    /[v]/;
    return '\v';
  } or {
    /[\\]/;
    return '\\';
  } or {
    /[']/;
    return '\'';
  } or {
    /["]/;
    return '"';
  }
}

func DecodeString (string) {
  /["]/;
  contents := []rune{};
  star {
    choose {
      append(contents, $[^"\\]);
    } or {
      /[\\]/;
      append(contents, EscapedChar());
    }
  }
  /["]/;
  return coerce(string, contents);
}

func DecodeRune (rune) {
  var value rune;
  /[']/;
  choose {
    value = $[^\\'];
  } or {
    /[\\]/;
    value = EscapedChar();
  }
  /[']/;
  return value;
}

func DecodeBool (bool) {
  choose {
    /"true"/;
    EndKeyword();
    return true;
  } or {
    /"false"/;
    EndKeyword();
    return false;
  }
}

func Literal (ASTExpr) {
  choose {
    var value rune;
    text := slice {
      value = DecodeRune();
    };
    return RuneLiteral{Text: text, Value: value};
  } or {
    var value string;
    text := slice {
      value = DecodeString();
    };
    return StringLiteral{Text: text, Value: value};
  } or {
    var value int;
    text := slice {
      value = DecodeInt();
    };
    return IntLiteral{Text: text, Value: value};
  } or {
    var value bool;
    text := slice {
      value = DecodeBool();
    };
    return BoolLiteral{Text: text, Value: value};
  }
}

func BinaryOperator (string) {
  op := /[+\-*/]|([<>][=]?)|([!=][=]) ![+\-*/<>!=]/;
  return op;
}


struct StringMatch implements ASTExpr {
   Match TextMatch
}

struct RuneMatch implements ASTExpr {
   Match RuneRangeMatch
}

func StringMatchExpr (StringMatch) {
  /[/]/;
  S();
  e := ParseMatchChoice();
  S();
  /[/]/;
  return StringMatch{Match: e};
}

func RuneMatchExpr (RuneMatch) {
  /[$]/;
  S();
  e := MatchRune();
  return RuneMatch{Match: e};
}


test Ident Alpha "a_B_c"
  Id{Text: "a_B_c"}

test Ident AlphaNum "a_1_7"
  Id{Text: "a_1_7"}

test Literal Num "1234567890"
  IntLiteral{
    Text: "1234567890"
    Value: 1234567890
 }

test Literal Str "\"hello, world\\n\""
  StringLiteral{
    Text: "\"hello, world\\n\""
    Value: "hello, world\n"
  }

test Literal Rune "'a'"
  RuneLiteral{
    Text: "'a'"
    Value: 'a'
  }

test Literal EscapedRune "'\\n'"
  RuneLiteral{
    Text: "'\\n'"
    Value: '\n'
  }

struct ASTDecl {
}

struct ASTType implements ASTDecl {
}

struct ASTTypeRef {
}

struct TypeRef implements ASTTypeRef {
  Name Id
  T ASTType
}

struct ListTypeRef implements ASTTypeRef {
  Type ASTTypeRef
  T ASTType
}

func ParseStructTypeRef (TypeRef) {
    return TypeRef{Name: Ident()};
}

func ParseListTypeRef (ListTypeRef) {
    /[\[][\]]/;
    return ListTypeRef{Type: ParseTypeRef()};
}


func ParseTypeRef (ASTTypeRef) {
  choose {
    return ParseStructTypeRef();
  } or {
    return ParseListTypeRef();
  }
}

test ParseTypeRef ListOfList "[][]Foo"
  ListTypeRef{
    Type: ListTypeRef{
      Type: TypeRef{
        Name: Id{Text: "Foo"}
      }
    }
  }

struct Destructure {
}

struct DestructureValue implements Destructure {
  Expr ASTExpr
}

struct DestructureField {
  Name Id
  Destructure Destructure
}

struct DestructureStruct implements Destructure {
  Type TypeRef
  Args []DestructureField
}

struct DestructureList implements Destructure {
  Type ListTypeRef
  Args []Destructure
}

func ParseDestructure (Destructure) {
  choose {
    t := ParseStructTypeRef();
    S();
    /[{]/;
    S();
    fields := []DestructureField{};
    star {
      name := Ident();
      S();
      /[:]/;
      S();
      d := ParseDestructure();
      S();
      append(fields, DestructureField{Name: name, Destructure: d});
    }
    /[}]/;
    return DestructureStruct{Type: t, Args: fields};
  } or {
    t := ParseListTypeRef();
    S();
    /[{]/;
    S();
    fields := []Destructure{};
    star {
      append(fields, ParseDestructure());
      S();
    }
    /[}]/;
    return DestructureList{Type: t, Args: fields};
  } or {
    return DestructureValue{Expr: Literal()};
  }
}

test ParseDestructure Compound "[]Foo { Bar { Baz: 1 Biz : 'x'} }"
  DestructureList {
    Type: ListTypeRef {
      Type: TypeRef {
        Name: Id{Text: "Foo"}
      }
    }
    Args: []Destructure {
      DestructureStruct {
        Type: TypeRef {
          Name: Id{Text: "Bar"}
        }
        Args: []DestructureField {
          DestructureField {
            Name: Id{Text: "Baz"}
            Destructure: DestructureValue {
              Expr: IntLiteral {
                Value: 1
              }
            }
          }
          DestructureField {
            Name: Id{Text: "Biz"}
            Destructure: DestructureValue {
              Expr: RuneLiteral {
                Value: 'x'
              }
            }
          }
        }
      }
    }
  }

func ParseRuneFilterRune (rune) {
  choose {
    return $[^\]\-\\];
  } or {
    /[\\]/;
    choose {
      return EscapedChar();
    } or {
      return $[^];
    }
  }
}

func ParseRuneFilter (RuneFilter) {
  min := ParseRuneFilterRune();
  max := min;
  question {
    /[\-]/;
    max = ParseRuneFilterRune();
  }
  return RuneFilter{Min: min, Max: max};
}

func MatchRune (RuneRangeMatch) {
  /[\[]/;
  invert := false;
  filters := []RuneFilter{};
  question {
    /[\^]/;
    invert = true;
  }
  star {
    append(filters, ParseRuneFilter());
  }
  /[\]]/;
  return RuneRangeMatch{Invert: invert, Filters: filters};
}

func Atom (TextMatch) {
  choose {
    return MatchRune();
  } or {
    value := DecodeString();
    return StringLiteralMatch{Value: value};
  } or {
    /[(]/;
    S();
    e := ParseMatchChoice();
    S();
    /[)]/;
    return e;
  }
}

func MatchPostfix (TextMatch) {
  e := Atom();
  choose {
    S();
    /[*]/;
    return MatchRepeat{Match: e, Min: 0};
  } or {
    S();
    /[+]/;
    return MatchRepeat{Match: e, Min: 1};
  } or {
    S();
    /[?]/;
    return MatchChoice{Matches: []TextMatch{e, MatchSequence{Matches: []TextMatch{}}}};
  } or {
    return e;
  }
}

func MatchPrefix (TextMatch) {
  choose {
    var invert bool;
    choose {
      /[!]/;
      invert = true;
    } or {
      /[&]/;
    }
    S();
    return MatchLookahead{Invert: invert, Match: MatchPostfix()};
  } or {
    return MatchPostfix();
  }
}

func Sequence (TextMatch) {
  e := MatchPrefix();
  choose {
    l := []TextMatch{e};
    plus {
      S();
      append(l, MatchPrefix());
    }
    return MatchSequence{Matches: l};
  } or {
    return e;
  }
}

func ParseMatchChoice (TextMatch) {
  e := Sequence();
  choose {
    l := []TextMatch{e};
    plus {
      S();
      /[|]/;
      S();
      append(l, Sequence());
    }
    return MatchChoice{Matches: l};
  } or {
    return e;
  }
}


test ParseMatchChoice One "[pq]"
  RuneRangeMatch {
    Invert: false
    Filters: []RuneFilter {
      RuneFilter {
        Min: 'p'
        Max: 'p'
      }
      RuneFilter {
        Min: 'q'
        Max: 'q'
      }
    }
  }

test ParseMatchChoice Invert "[^.]"
  RuneRangeMatch {
    Invert: true
    Filters: []RuneFilter {
      RuneFilter {
        Min: '.'
        Max: '.'
      }
    }
  }

test ParseMatchChoice Escape "[\\]\\n]"
  RuneRangeMatch {
    Filters: []RuneFilter {
      RuneFilter {
        Min: ']'
        Max: ']'
      }
      RuneFilter {
        Min: '\n'
        Max: '\n'
      }
    }
  }


test ParseMatchChoice Three "[a][b][c]"
  MatchSequence {
    Matches: []TextMatch {
      RuneRangeMatch {
        Filters: []RuneFilter {
          RuneFilter {
            Min: 'a'
            Max: 'a'
          }
        }
      }
      RuneRangeMatch {
        Filters: []RuneFilter {
          RuneFilter {
            Min: 'b'
            Max: 'b'
          }
        }
      }
      RuneRangeMatch {
        Filters: []RuneFilter {
          RuneFilter {
            Min: 'c'
            Max: 'c'
          }
        }
      }
    }
  }

test ParseMatchChoice Repeat "[0-9] +"
  MatchRepeat {
    Match: RuneRangeMatch {
      Filters: []RuneFilter {
        RuneFilter {
          Min: '0'
          Max: '9'
        }
      }
    }
    Min: 1
  }

test ParseMatchChoice Question "[*]?"
  MatchChoice {
    Matches: []TextMatch {
      RuneRangeMatch {
        Filters: []RuneFilter {
          RuneFilter {
            Min: '*'
            Max: '*'
          }
        }
      }
      MatchSequence {
        Matches: []TextMatch{}
      }
    }
  }

test ParseMatchChoice Complex "[a] ( [b]|[c] ) | [d]"
  MatchChoice {
    Matches: []TextMatch {
      MatchSequence {
        Matches: []TextMatch{
          RuneRangeMatch {
            Filters: []RuneFilter {
              RuneFilter {
                Min: 'a'
                Max: 'a'
               }
            }
          }
          MatchChoice {
            Matches: []TextMatch {
              RuneRangeMatch {
                Filters: []RuneFilter {
                  RuneFilter {
                    Min: 'b'
                    Max: 'b'
                  }
                }
              }
              RuneRangeMatch {
                Filters: []RuneFilter {
                  RuneFilter {
                    Min: 'c'
                    Max: 'c'
                  }
                }
              }
            }
          }
        }
      }
      RuneRangeMatch {
        Filters: []RuneFilter {
          RuneFilter {
            Min: 'd'
            Max: 'd'
          }
        }
      }
    }
  }

test ParseMatchChoice PositiveLookahead "&[.]"
  MatchLookahead {
    Invert: false
    Match: RuneRangeMatch {
      Invert: false
      Filters: []RuneFilter {
        RuneFilter {
          Min: '.'
          Max: '.'
        }
      }
    }
  }

test ParseMatchChoice NegativeLookahead "![.]"
  MatchLookahead {
    Invert: true
    Match: RuneRangeMatch {
      Invert: false
      Filters: []RuneFilter {
        RuneFilter {
          Min: '.'
          Max: '.'
        }
      }
    }
  }


struct If implements ASTExpr {
  Expr ASTExpr
  Block []ASTExpr
}

struct Repeat implements ASTExpr {
  Block []ASTExpr
  Min int
}

struct Choice implements ASTExpr {
  Blocks [][]ASTExpr
}

struct Optional implements ASTExpr {
  Block []ASTExpr
}

struct Slice implements ASTExpr {
  Block []ASTExpr
}

struct Assign implements ASTExpr {
  Expr ASTExpr
  Name Id
  Info int
  Type ASTTypeRef
  Define bool
}

struct GetName implements ASTExpr {
  Name Id
  Info int
}

struct NamedExpr {
  Name Id
  Expr ASTExpr
}

struct Construct implements ASTExpr {
  Type TypeRef
  Args []NamedExpr
}

struct ConstructList implements ASTExpr {
  Type ListTypeRef
  Args []ASTExpr
}

struct Coerce implements ASTExpr {
  Type ASTTypeRef
  Expr ASTExpr
}

struct Call implements ASTExpr {
  Name Id
  T ASTType
}

struct Position implements ASTExpr {
}

struct Fail implements ASTExpr {
}

struct Append implements ASTExpr {
  List ASTExpr
  Expr ASTExpr
  T ASTType
}

struct Return implements ASTExpr {
  Exprs []ASTExpr
}

struct BinaryOp implements ASTExpr {
  Left ASTExpr
  Op string
  Right ASTExpr
  T ASTType
}

func ParseExprList ([]ASTExpr) {
  exprs := []ASTExpr{};
  question {
    append(exprs, ParseExpr());
    star {
      S();
      /[,]/;
      S();
      append(exprs, ParseExpr());
    }
  }
  return exprs;
}

func ParseNamedExpr (NamedExpr) {
  name := Ident();
  S();
  /[:]/;
  S();
  return NamedExpr{Name: name, Expr: ParseExpr()};
}

func ParseNamedExprList ([]NamedExpr) {
  exprs := []NamedExpr{};
  question {
    append(exprs, ParseNamedExpr());
    star {
      S();
      /[,]/;
      S();
      append(exprs, ParseNamedExpr());
    }
  }
  return exprs;
}


func ParseTypeList ([]ASTTypeRef) {
  /[(]/;
  S();
  types := []ASTTypeRef{};
  question {
    append(types, ParseTypeRef());
    S();
    star {
      /[,]/;
      S();
      append(types, ParseTypeRef());
      S();
    }
  }
  /[)]/;
  return types;
}

func PrimaryExpr (ASTExpr) {
  choose {
    return Literal();
  } or {
    /"slice"/;
    EndKeyword();
    S();
    block := ParseCodeBlock();
    return Slice{Block: block};
  } or {
    /"position"/;
    EndKeyword();
    return Position{};
  } or {
    /"coerce"/;
    EndKeyword();
    S();
    /[(]/;
    S();
    t := ParseTypeRef();
    S();
    /[,]/;
    S();
    e := ParseExpr();
    S();
    /[)]/;
    return Coerce{Type: t, Expr: e};
  } or {
    /"append"/;
    EndKeyword();
    S();
    /[(]/;
    S();
    name := Ident();
    S();
    /[,]/;
    S();
    expr := ParseExpr();
    S();
    /[)]/;
    return Assign{
      Expr: Append{
        List: GetName{Name: name},
        Expr: expr
      },
      Name: name
    };
  } or {
    name := Ident();
    S();
    /[(]/;
    S();
    /[)]/;
    return Call{Name: name};
  } or {
    t := ParseStructTypeRef();
    S();
    /[{]/;
    S();
    args := ParseNamedExprList();
    S();
    /[}]/;
    return Construct{Type: t, Args: args};
  } or {
    t := ParseListTypeRef();
    S();
    /[{]/;
    S();
    args := ParseExprList();
    S();
    /[}]/;
    return ConstructList{Type: t, Args: args};
  } or {
    return StringMatchExpr();
  } or {
    return RuneMatchExpr();
  } or {
    /[(]/;
    S();
    e := ParseExpr();
    S();
    /[)]/;
    return e;
  } or {
    name := Ident();
    return GetName{Name: name};
  }
}

func ParseExpr (ASTExpr) {
  e := PrimaryExpr();
  star {
    S();
    op := BinaryOperator();
    S();
    r := PrimaryExpr();
    e = BinaryOp{Left: e, Op: op, Right: r};
  }
  return e;
}

func ParseCompoundStatement (ASTExpr) {
  choose {
    /"star"/;
    EndKeyword();
    S();
    block := ParseCodeBlock();
    return Repeat{Block: block, Min: 0};
  } or {
    /"plus"/;
    EndKeyword();
    S();
    block := ParseCodeBlock();
    return Repeat{Block: block, Min: 1};
  } or {
    /"choose"/;
    EndKeyword();
    S();
    blocks := [][]ASTExpr{ParseCodeBlock()};
    star {
      S();
      /"or"/;
      EndKeyword();
      S();
      append(blocks, ParseCodeBlock());
    }
    return Choice{Blocks: blocks};
  } or {
    /"question"/;
    EndKeyword();
    S();
    block := ParseCodeBlock();
    return Optional{Block: block};
  } or {
    /"if"/;
    EndKeyword();
    S();
    expr := ParseExpr();
    S();
    block := ParseCodeBlock();
    return If{Expr: expr, Block: block};
  }
}

func EOS () {
  S();
  /[;]/;
}

func ParseStatement (ASTExpr) {
  choose {
    return ParseCompoundStatement();
  } or {
    /"var"/;
    EndKeyword();
    S();
    name := Ident();
    S();
    t := ParseTypeRef();
    var expr ASTExpr;
    question {
      S();
      /[=]/;
      S();
      expr = ParseExpr(); 
    }
    EOS();
    return Assign{Expr: expr, Name: name, Type: t, Define: true};
  } or {
    /"fail"/;
    EndKeyword();
    EOS();
    return Fail{};
  } or {
    /"return"/;
    EndKeyword();
    S();
    exprs := ParseExprList();
    EOS();
    return Return{Exprs: exprs};
  } or {
    name := Ident();
    S();
    var defined bool;
    choose {
      /":="/;
      defined = true;
    } or {
      /"="/;
    }
    S();
    expr := ParseExpr();
    EOS();
    return Assign{Expr: expr, Name: name, Define: defined};
  } or {
    e := ParseExpr();
    EOS();
    return e;
  }
}

func ParseCodeBlock([]ASTExpr) {
  /[{]/;
  S();
  exprs := []ASTExpr{};
  star {
    append(exprs, ParseStatement());
    S();
  }
  /[}]/;
  return exprs;
}

test ParseExpr BinaryOpLeft "12 + 34 - 56"
  BinaryOp {
    Left: BinaryOp {
      Left: IntLiteral {
        Value: 12
      }
      Op: "+"
      Right: IntLiteral {
        Value: 34
      }
    }
    Op: "-"
    Right: IntLiteral {
      Value: 56
    }
  }

test ParseExpr BinaryOpRight "12 + (34 - 56)"
  BinaryOp {
    Left: IntLiteral {
      Value: 12
    }
    Op: "+"
    Right: BinaryOp {
      Left: IntLiteral {
        Value: 34
      }
      Op: "-"
      Right: IntLiteral {
        Value: 56
      }
    }
  }


test ParseStatement Assign "foo = 1;"
  Assign {
    Name: Id{Text: "foo"}
    Expr: IntLiteral {
      Value: 1
    }
    Define: false
  }

test ParseStatement Lookahead "returnType = 1;"
  Assign {
    Name: Id{Text: "returnType"}
    Expr: IntLiteral {
      Value: 1
    }
    Define: false
  }

test ParseStatement Define "foo := 1;"
  Assign {
    Name: Id{Text: "foo"}
    Expr: IntLiteral {
      Value: 1
    }
    Define: true
  }

test ParseExpr Construct "Foo{ Bar: 1}"
  Construct {
    Type: TypeRef {
      Name: Id{Text: "Foo"}
    }
    Args: []NamedExpr {
      NamedExpr{
        Name: Id{Text: "Bar"}
        Expr: IntLiteral {
          Value: 1
        }
      }
    }
  }

test ParseExpr ConstructList "[]Foo{ 1 }"
  ConstructList {
    Type: ListTypeRef{
      Type: TypeRef {
        Name: Id{Text: "Foo"}
      }
    }
    Args: []ASTExpr {
      IntLiteral {
        Value: 1
      }
    }
  }

test ParseStatement Slice "a := slice { 1; } ;"
  Assign {
    Expr: Slice{
      Block: []ASTExpr{
        IntLiteral {
          Value: 1
        }
      }
    }
    Name: Id{Text: "a"}
    Define: true
  }

struct BuiltinType implements ASTType {
  Name string
}

struct ListType implements ASTType {
  Type ASTType
}

struct FieldDecl {
  Name Id
  Type ASTTypeRef
}

struct StructDecl implements ASTType {
  Name Id
  Implements ASTTypeRef
  Fields []FieldDecl
}


func ParseStructDecl (StructDecl) {
  /"struct"/;
  EndKeyword();
  S();
  name := Ident();
  S();
  var implements ASTTypeRef;
  question {
    /"implements"/;
    EndKeyword();
    S();
    implements = ParseTypeRef();
    S();
  }
  /[{]/;
  S();
  fields := []FieldDecl{};
  star {
    fn := Ident();
    S();
    ft := ParseTypeRef();
    S();
    append(fields, FieldDecl{Name: fn, Type: ft});
  }
  /[}]/;
  return StructDecl{Name: name, Implements: implements, Fields: fields};
}

struct ASTFunc implements ASTDecl {
}

struct LocalInfo {
  Name string
  T ASTType
}

struct FuncDecl implements ASTFunc {
  Name Id
  ReturnTypes []ASTTypeRef
  Block []ASTExpr
  Locals []LocalInfo
}

func ParseFuncDecl (FuncDecl) {
  /"func"/;
  EndKeyword();
  S();
  name := Ident();
  S();
  retTypes := ParseTypeList();
  S();
  block := ParseCodeBlock();
  return FuncDecl{Name: name, ReturnTypes: retTypes, Block: block};
}

struct Test {
  Rule Id
  Name Id
  Type ASTType
  Input string
  Destructure Destructure
}

func ParseTest (Test) {
  /"test"/;
  EndKeyword();
  S();
  rule := Ident();
  S();
  name := Ident();
  S();
  input := DecodeString();
  S();
  d := ParseDestructure();
  return Test{Rule: rule, Name: name, Input: input, Destructure: d};
}

struct File {
  Decls []ASTDecl
  Tests []Test
}

func ParseFile (File) {
  decls := []ASTDecl{};
  tests := []Test{};
  S();
  star {
    choose {
      append(decls, ParseFuncDecl());
    } or {
      append(decls, ParseStructDecl());
    } or {
      append(tests, ParseTest());
    }
    S();
  }
  /![^]/;
  return File{Decls: decls, Tests: tests};
}
