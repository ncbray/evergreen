struct TextMatch {
}

struct RuneFilter {
  Min rune
  Max rune
}

struct RuneRangeMatch implements TextMatch {
  Invert bool
  Filters []RuneFilter
}

struct StringLiteralMatch implements TextMatch {
  Value string
}

struct MatchSequence implements TextMatch {
  Matches []TextMatch
}

struct MatchChoice implements TextMatch {
  Matches []TextMatch
}

struct MatchRepeat implements TextMatch {
  Match TextMatch
  Min int
}

struct ASTExpr {
}

struct RuneLiteral implements ASTExpr {
  Text string
  Value rune
}

struct StringLiteral implements ASTExpr {
  Text string
  Value string
}

struct IntLiteral implements ASTExpr {
  Text string
  Value int
}

struct BoolLiteral implements ASTExpr {
  Text string
  Value bool
}

func S () {
  /[ \t\r\n]*/;
}

func Ident (string) {
  define text /[a-zA-Z_][a-zA-Z_0-9]*/;
  call S;
  return text;
}

func DecodeInt (int) {
    var value int;
    plus {
      define digit - coerce int $[0-9] coerce int '0';
      assign value + * value 10 digit;
    }
    return value;
}

func EscapedChar (rune) {
  choose {
    /[a]/;
    return '\a';
  } or {
    /[b]/;
    return '\b';
  } or {
    /[f]/;
    return '\f';
  } or {
    /[n]/;
    return '\n';
  } or {
    /[r]/;
    return '\r';
  } or {
    /[t]/;
    return '\t';
  } or {
    /[v]/;
    return '\v';
  } or {
    /[\\]/;
    return '\\';
  } or {
    /[']/;
    return '\'';
  } or {
    /["]/;
    return '"';
  }
}

func DecodeString (string) {
  /["]/;
  define contents conl []rune()
  star {
    choose {
      append contents $[^"\\];
    } or {
      /[\\]/;
      append contents call EscapedChar;
    }
  }
  /["]/;
  return coerce string contents;
}

func DecodeRune (rune) {
  var value rune;
  /[']/;
  choose {
    assign value $[^\\'];
  } or {
    /[\\]/;
    assign value call EscapedChar;
  }
  /[']/;
  return value;
}

func DecodeBool (bool) {
  choose {
    /"true"/;
    return true;
  } or {
    /"false"/;
    return false;
  }
}

func Literal (ASTExpr) {
  choose {
    var value rune;
    define text slice {
      assign value call DecodeRune;
    }
    call S;
    return cons RuneLiteral(Text: text, Value: value);
  } or {
    var value string;
    define text slice {
      assign value call DecodeString;
    }
    call S;
    return cons StringLiteral(Text: text, Value: value);
  } or {
    var value int;
    define text slice {
      assign value call DecodeInt;
    }
    call S;
    return cons IntLiteral(Text: text, Value: value);
  } or {
    var value bool;
    define text slice {
      assign value call DecodeBool;
    }
    call S;
    return cons BoolLiteral(Text: text, Value: value);
  }
}

func BinaryOperator (string) {
  define op /[+\-*/]|([<>][=]?)|([!=][=])/;
  call S;
  return op;
}


struct StringMatch implements ASTExpr {
   Match TextMatch
}

struct RuneMatch implements ASTExpr {
   Match RuneRangeMatch
}

func StringMatchExpr (StringMatch) {
  /[/]/;
  call S;
  define e call ParseMatchChoice;
  /[/]/;
  call S;
  return cons StringMatch(Match: e);
}

func RuneMatchExpr (RuneMatch) {
  /[$]/;
  call S;
  define e call MatchRune;
  return cons RuneMatch(Match: e);
}


test Ident Alpha "a_B_c "
  "a_B_c"

test Ident AlphaNum "a_1_7  "
  "a_1_7"

test Literal Num "1234567890  "
  IntLiteral{
    Text: "1234567890"
    Value: 1234567890
 }

test Literal Str "\"hello, world\\n\"  "
  StringLiteral{
    Text: "\"hello, world\\n\""
    Value: "hello, world\n"
  }

test Literal Rune "'a'  "
  RuneLiteral{
    Text: "'a'"
    Value: 'a'
  }

test Literal EscapedRune "'\\n'  "
  RuneLiteral{
    Text: "'\\n'"
    Value: '\n'
  }

struct ASTType {
}

struct Fake implements ASTType {
}

struct ASTTypeRef {
}

struct TypeRef implements ASTTypeRef {
  Name string
  T ASTType
}

struct ListTypeRef implements ASTTypeRef {
  Type ASTTypeRef
  T ASTType
}

func ParseStructTypeRef (TypeRef) {
    define name call Ident;
    return cons TypeRef(Name: name);
}

func ParseListTypeRef (ListTypeRef) {
    /[\[][\]]/;
    define t call ParseTypeRef;
    return cons ListTypeRef(Type: t);
}


func ParseTypeRef (ASTTypeRef) {
  choose {
    return call ParseStructTypeRef;
  } or {
    return call ParseListTypeRef;
  }
}

test ParseTypeRef ListOfList "[][]Foo"
  ListTypeRef{
    Type: ListTypeRef{
      Type: TypeRef{
        Name: "Foo"
      }
    }
  }

struct Destructure {
}

struct DestructureValue implements Destructure {
  Expr ASTExpr
}

struct DestructureField {
  Name string
  Destructure Destructure
}

struct DestructureStruct implements Destructure {
  Type TypeRef
  Args []DestructureField
}

struct DestructureList implements Destructure {
  Type ListTypeRef
  Args []Destructure
}

func ParseDestructure (Destructure) {
  choose {
    define t call ParseStructTypeRef;
    /[{]/;
    call S;
    define fields conl []DestructureField();
    star {
      define name call Ident;
      /[:]/;
      call S;
      define d call ParseDestructure;
      append fields cons DestructureField(Name: name, Destructure: d);
    }
    /[}]/;
    call S;
    return cons DestructureStruct(Type: t, Args: fields);
  } or {
    define t call ParseListTypeRef;
    /[{]/;
    call S;
    define fields conl []Destructure();
    star {
      append fields call ParseDestructure;
    }
    /[}]/;
    call S;
    return cons DestructureList(Type: t, Args: fields);
  } or {
    return cons DestructureValue(Expr: call Literal)
  }
}

test ParseDestructure Compound "[]Foo { Bar { Baz: 1 Biz : 'x'} } "
  DestructureList {
    Type: ListTypeRef {
      Type: TypeRef {
        Name: "Foo"
      }
    }
    Args: []Destructure {
      DestructureStruct {
        Type: TypeRef {
          Name: "Bar"
        }
        Args: []DestructureField {
          DestructureField {
            Name: "Baz"
            Destructure: DestructureValue {
              Expr: IntLiteral {
                Value: 1
              }
            }
          }
          DestructureField {
            Name: "Biz"
            Destructure: DestructureValue {
              Expr: RuneLiteral {
                Value: 'x'
              }
            }
          }
        }
      }
    }
  }

func ParseRuneFilterRune (rune) {
  choose {
    return $[^\]\-\\];
  } or {
    /[\\]/;
    choose {
      return call EscapedChar;
    } or {
      return $[^];
    }
  }
}

func ParseRuneFilter (RuneFilter) {
  define min call ParseRuneFilterRune;
  define max min;
  question {
    /[\-]/;
    assign max call ParseRuneFilterRune;
  }
  return cons RuneFilter(Min: min, Max: max);
}

func MatchRune (RuneRangeMatch) {
  /[\[]/;
  define invert false;
  define filters conl []RuneFilter();
  question {
    /[\^]/;
    assign invert true;
  }
  star {
    append filters call ParseRuneFilter;
  }
  /[\]]/;
  call S;
  return cons RuneRangeMatch(Invert: invert, Filters: filters)
}

func Atom (TextMatch) {
  choose {
    return call MatchRune;
  } or {
    define value call DecodeString;
    call S;
    return cons StringLiteralMatch(Value: value)
  } or {
    /[(]/;
    define e call ParseMatchChoice;
    /[)]/;
    return e;
  }
}

func Postfix (TextMatch) {
  define e call Atom;
  choose {
    /[*]/;
    call S;
    return cons MatchRepeat(Match: e, Min: 0);
  } or {
    /[+]/;
    call S;
    return cons MatchRepeat(Match: e, Min: 1);
  } or {
    /[?]/;
    call S;
    return cons MatchChoice(Matches: conl []TextMatch(e, cons MatchSequence(Matches: conl []TextMatch())));
  } or {
    return e;
  }
}

func Sequence (TextMatch) {
  define e call Postfix;
  choose {
    define l conl []TextMatch(e)
    plus {
      append l call Postfix;
    }
    return cons MatchSequence(Matches: l);
  } or {
    return e;
  }
}

func ParseMatchChoice (TextMatch) {
  define e call Sequence;
  choose {
    define l conl []TextMatch(e);
    plus {
      /[|]/;
      call S;
      append l call Sequence;
    }
    return cons MatchChoice(Matches: l);
  } or {
    return e;
  }
}


test ParseMatchChoice One "[pq]"
  RuneRangeMatch {
    Invert: false
    Filters: []RuneFilter {
      RuneFilter {
        Min: 'p'
        Max: 'p'
      }
      RuneFilter {
        Min: 'q'
        Max: 'q'
      }
    }
  }

test ParseMatchChoice Invert "[^.]"
  RuneRangeMatch {
    Invert: true
    Filters: []RuneFilter {
      RuneFilter {
        Min: '.'
        Max: '.'
      }
    }
  }

test ParseMatchChoice Escape "[\\]\\n]"
  RuneRangeMatch {
    Filters: []RuneFilter {
      RuneFilter {
        Min: ']'
        Max: ']'
      }
      RuneFilter {
        Min: '\n'
        Max: '\n'
      }
    }
  }


test ParseMatchChoice Three "[a][b][c]"
  MatchSequence {
    Matches: []TextMatch {
      RuneRangeMatch {
        Filters: []RuneFilter {
          RuneFilter {
            Min: 'a'
            Max: 'a'
          }
        }
      }
      RuneRangeMatch {
        Filters: []RuneFilter {
          RuneFilter {
            Min: 'b'
            Max: 'b'
          }
        }
      }
      RuneRangeMatch {
        Filters: []RuneFilter {
          RuneFilter {
            Min: 'c'
            Max: 'c'
          }
        }
      }
    }
  }

test ParseMatchChoice Repeat "[0-9] + "
  MatchRepeat {
    Match: RuneRangeMatch {
      Filters: []RuneFilter {
        RuneFilter {
          Min: '0'
          Max: '9'
        }
      }
    }
    Min: 1
  }

test ParseMatchChoice Question "[*]?"
  MatchChoice {
    Matches: []TextMatch {
      RuneRangeMatch {
        Filters: []RuneFilter {
          RuneFilter {
            Min: '*'
            Max: '*'
          }
        }
      }
      MatchSequence {
        Matches: []TextMatch{}
      }
    }
  }

test ParseMatchChoice Complex "[a]([b]|[c])|[d]"
  MatchChoice {
    Matches: []TextMatch {
      MatchSequence {
        Matches: []TextMatch{
          RuneRangeMatch {
            Filters: []RuneFilter {
              RuneFilter {
                Min: 'a'
                Max: 'a'
               }
            }
          }
          MatchChoice {
            Matches: []TextMatch {
              RuneRangeMatch {
                Filters: []RuneFilter {
                  RuneFilter {
                    Min: 'b'
                    Max: 'b'
                  }
                }
              }
              RuneRangeMatch {
                Filters: []RuneFilter {
                  RuneFilter {
                    Min: 'c'
                    Max: 'c'
                  }
                }
              }
            }
          }
        }
      }
      RuneRangeMatch {
        Filters: []RuneFilter {
          RuneFilter {
            Min: 'd'
            Max: 'd'
          }
        }
      }
    }
  }

struct If implements ASTExpr {
  Expr ASTExpr
  Block []ASTExpr
}

struct Repeat implements ASTExpr {
  Block []ASTExpr
  Min int
}

struct Choice implements ASTExpr {
  Blocks [][]ASTExpr
}

struct Optional implements ASTExpr {
  Block []ASTExpr
}

struct Slice implements ASTExpr {
  Block []ASTExpr
}

struct Assign implements ASTExpr {
  Expr ASTExpr
  Name string
  Info int
  Type ASTTypeRef
  Define bool
}

struct GetName implements ASTExpr {
  Name string
  Info int
}

struct NamedExpr {
  Name string
  Expr ASTExpr
}

struct Construct implements ASTExpr {
  Type TypeRef
  Args []NamedExpr
}

struct ConstructList implements ASTExpr {
  Type ListTypeRef
  Args []ASTExpr
}

struct Coerce implements ASTExpr {
  Type ASTTypeRef
  Expr ASTExpr
}

struct Call implements ASTExpr {
  Name string
  T ASTType
}

struct Fail implements ASTExpr {
}

struct Append implements ASTExpr {
  List ASTExpr
  Expr ASTExpr
  T ASTType
}

struct Return implements ASTExpr {
  Exprs []ASTExpr
}

struct BinaryOp implements ASTExpr {
  Left ASTExpr
  Op string
  Right ASTExpr
  T ASTType
}

func ParseExprList ([]ASTExpr) {
  /[(]/;
  call S;
  define exprs conl []ASTExpr()
  question {
    append exprs call ParseExpr;
    star {
      /[,]/;
      call S;
      append exprs call ParseExpr;
    }
  }
  /[)]/;
  call S;
  return exprs;
}

func ParseNamedExpr (NamedExpr) {
  define name call Ident;
  /[:]/;
  call S;
  return cons NamedExpr(Name: name, Expr: call ParseExpr);
}

func ParseNamedExprList ([]NamedExpr) {
  /[(]/;
  call S;
  define exprs conl []NamedExpr()
  question {
    append exprs call ParseNamedExpr;
    star {
      /[,]/;
      call S;
      append exprs call ParseNamedExpr;
    }
  }
  /[)]/;
  call S;
  return exprs;
}


func ParseTypeList ([]ASTTypeRef) {
  /[(]/;
  call S;
  define types conl []ASTTypeRef()
  question {
    append types call ParseTypeRef;
    star {
      /[,]/;
      call S;
      append types call ParseTypeRef;
    }
  }
  /[)]/;
  call S;
  return types;
}

func ParseExpr (ASTExpr) {
  choose {
    return call Literal;
  } or {
    var count int
    choose {
      /"star"/;
    } or {
      /"plus"/;
      assign count 1;
    }
    call S;
    define block call ParseCodeBlock;
    return cons Repeat(Block: block, Min: count);
  } or {
    /"choose"/;
    call S;
    define blocks conl [][]ASTExpr(call ParseCodeBlock)
    star {
      /"or"/;
      call S;
      append blocks call ParseCodeBlock;
    }
    return cons Choice(Blocks: blocks);
  } or {
    /"question"/;
    call S;
    define block call ParseCodeBlock;
    return cons Optional(Block: block);
  } or {
    /"slice"/;
    call S;
    define block call ParseCodeBlock;
    return cons Slice(Block: block);
  } or {
    /"if"/;
    call S;
    define expr call ParseExpr;
    define block call ParseCodeBlock;
    return cons If(Expr: expr, Block: block);
  } or {
    /"var"/;
    call S;
    define name call Ident;
    define t call ParseTypeRef;
    var expr ASTExpr;
    question {
      /[=]/;
      call S;
      assign expr call ParseExpr; 
    }
    return cons Assign(Expr: expr, Name: name, Type: t, Define: true);
  } or {
    var defined bool;
    choose {
      /"assign"/;
    } or {
      /"define"/;
      assign defined true;
    }
    call S;
    define name call Ident;
    define expr call ParseExpr;
    return cons Assign(Expr: expr, Name: name, Define: defined);
  } or {
    /"cons"/;
    call S;
    define t call ParseStructTypeRef;
    define args call ParseNamedExprList;
    return cons Construct(Type: t, Args: args)
  } or {
    /"conl"/;
    call S;
    define t call ParseListTypeRef;
    define args call ParseExprList;
    return cons ConstructList(Type: t, Args: args)
  } or {
    /"call"/;
    call S;
    define name call Ident;
    return cons Call(Name: name);
  } or {
    /"fail"/;
    call S;
    return cons Fail();
  } or {
    /"coerce"/;
    call S;
    define t call ParseTypeRef;
    define e call ParseExpr;
    return cons Coerce(Type: t, Expr: e);
  } or {
    /"append"/;
    call S;
    define name call Ident;
    define expr call ParseExpr;
    return cons Assign(
      Expr: cons Append(
        List: cons GetName(Name: name),
        Expr: expr
      ),
      Name: name
    );
  } or {
    /"return"/;
    call S;
    choose {
      return cons Return(Exprs: call ParseExprList)
    } or {
      return cons Return(Exprs: conl []ASTExpr(call ParseExpr))
    } or {
      return cons Return(Exprs: conl []ASTExpr())
    }
  } or {
    define op call BinaryOperator;
    define l call ParseExpr;
    define r call ParseExpr;
    return cons BinaryOp(Left: l, Op: op, Right: r);
  } or {
    return call StringMatchExpr;
  } or {
    return call RuneMatchExpr;
  } or {
    return cons GetName(Name: call Ident);
  }
}

func ParseCodeBlock([]ASTExpr) {
  /[{]/;
  call S;
  define exprs conl []ASTExpr();
  star {
    append exprs call ParseExpr;
    star {
      /[;]/;
      call S;
    }
  }
  /[}]/;
  call S;
  return exprs;
}

test ParseExpr BinaryOp "+ 1 2"
  BinaryOp {
    Left: IntLiteral {
      Value: 1
    }
    Op: "+"
    Right: IntLiteral {
      Value: 2
    }
  }