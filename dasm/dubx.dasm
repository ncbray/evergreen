struct TextMatch {
}

struct RuneFilter {
  Min rune
  Max rune
}

struct RuneMatch implements TextMatch {
  Invert bool
  Filters []RuneFilter
}

struct MatchSequence implements TextMatch {
  Matches []TextMatch
}

struct MatchChoice implements TextMatch {
  Matches []TextMatch
}

struct MatchRepeat implements TextMatch {
  Match TextMatch
  Min int
}

struct Token {
}

struct IntTok implements Token {
  Text string
  Value int
}

struct StrTok implements Token {
  Text string
  Value string
}

struct RuneTok implements Token {
  Text string
  Value rune
}

func S () {
  /[ \t\r\n]*/;
}

func Ident (string) {
  define text /[a-zA-Z_][a-zA-Z_0-9]*/;
  call S;
  return text;
}

func Int (IntTok) {
  define text /[0-9]+/;
  call S;
  return cons IntTok(Text: text);
}

func EscapedChar (rune) {
  choose {
    /[a]/;
    return '\a';
  } or {
    /[b]/;
    return '\b';
  } or {
    /[f]/;
    return '\f';
  } or {
    /[n]/;
    return '\n';
  } or {
    /[r]/;
    return '\r';
  } or {
    /[t]/;
    return '\t';
  } or {
    /[v]/;
    return '\v';
  } or {
    /[\\]/;
    return '\\';
  } or {
    /[']/;
    return '\'';
  } or {
    /["]/;
    return '"';
  }
}

func StrT (StrTok) {
  define text slice {
    /["]/;
    define contents conl []rune()
    star {
      choose {
        append contents $[^"\\];
      } or {
        /[\\]/;
        append contents call EscapedChar;
      }
    }
    /["]/;
  }
  call S;
  return cons StrTok(Text: text, Value: coerce string contents);
}

func Rune (RuneTok) {
  var value rune;
  define text slice {
    /[']/;
    choose {
      assign value $[^\\'];
    } or {
      /[\\]/;
      assign value call EscapedChar;
    }
    /[']/;
  }
  call S;
  return cons RuneTok(Text: text, Value: value);
}

func StringMatchExpr (TextMatch) {
  /[/]/;
  call S;
  define e call Choice;
  /[/]/;
  call S;
  return e;
}

func RuneMatchExpr (RuneMatch) {
  /[$]/;
  call S;
  define e call MatchRune;
  return e;
}


test Ident Alpha "a_B_c "
  "a_B_c"

test Ident AlphaNum "a_1_7  "
  "a_1_7"

test Int Num "1234567890  "
  IntTok{Text: "1234567890"}

test StrT Str "\"hello, world\\n\"  "
  StrTok{
    Text: "\"hello, world\\n\""
    Value: "hello, world\n"
  }

test Rune Rune "'a'  "
  RuneTok{
    Text: "'a'"
    Value: 'a'
  }

test Rune Escaped "'\\n'  "
  RuneTok{
    Text: "'\\n'"
    Value: '\n'
  }


func ParseRuneFilterRune (rune) {
  choose {
    return $[^\]\-\\];
  } or {
    /[\\]/;
    choose {
      return call EscapedChar;
    } or {
      return $[^];
    }
  }
}

func ParseRuneFilter (RuneFilter) {
  define min call ParseRuneFilterRune;
  define max min;
  question {
    /[\-]/;
    assign max call ParseRuneFilterRune;
  }
  return cons RuneFilter(Min: min, Max: max);
}

func MatchRune (RuneMatch) {
  /[\[]/;
  define invert false;
  define filters conl []RuneFilter();
  question {
    /[\^]/;
    assign invert true;
  }
  star {
    append filters call ParseRuneFilter;
  }
  /[\]]/;
  call S;
  return cons RuneMatch(Invert: invert, Filters: filters)
}

func Atom (TextMatch) {
  choose {
    return call MatchRune;
  } or {
    /[(]/;
    define e call Choice;
    /[)]/;
    return e;
  }
}

func Postfix (TextMatch) {
  define e call Atom;
  choose {
    /[*]/;
    call S;
    return cons MatchRepeat(Match: e, Min: 0);
  } or {
    /[+]/;
    call S;
    return cons MatchRepeat(Match: e, Min: 1);
  } or {
    /[?]/;
    call S;
    return cons MatchChoice(Matches: conl []TextMatch(e, cons MatchSequence(Matches: conl []TextMatch())));
  } or {
    return e;
  }
}

func Sequence (TextMatch) {
  define e call Postfix;
  choose {
    define l conl []TextMatch(e)
    plus {
      append l call Postfix;
    }
    return cons MatchSequence(Matches: l);
  } or {
    return e;
  }
}

func Choice (TextMatch) {
  define e call Sequence;
  choose {
    define l conl []TextMatch(e);
    plus {
      /[|]/;
      call S;
      append l call Sequence;
    }
    return cons MatchChoice(Matches: l);
  } or {
    return e;
  }
}


test Choice One "[pq]"
  RuneMatch {
    Invert: false
    Filters: []RuneFilter {
      RuneFilter {
        Min: 'p'
        Max: 'p'
      }
      RuneFilter {
        Min: 'q'
        Max: 'q'
      }
    }
  }

test Choice Invert "[^.]"
  RuneMatch {
    Invert: true
    Filters: []RuneFilter {
      RuneFilter {
        Min: '.'
        Max: '.'
      }
    }
  }

test Choice Escape "[\\]\\n]"
  RuneMatch {
    Filters: []RuneFilter {
      RuneFilter {
        Min: ']'
        Max: ']'
      }
      RuneFilter {
        Min: '\n'
        Max: '\n'
      }
    }
  }


test Choice Three "[a][b][c]"
  MatchSequence {
    Matches: []TextMatch {
      RuneMatch {
        Filters: []RuneFilter {
          RuneFilter {
            Min: 'a'
            Max: 'a'
          }
        }
      }
      RuneMatch {
        Filters: []RuneFilter {
          RuneFilter {
            Min: 'b'
            Max: 'b'
          }
        }
      }
      RuneMatch {
        Filters: []RuneFilter {
          RuneFilter {
            Min: 'c'
            Max: 'c'
          }
        }
      }
    }
  }

test Choice Repeat "[0-9] + "
  MatchRepeat {
    Match: RuneMatch {
      Filters: []RuneFilter {
        RuneFilter {
          Min: '0'
          Max: '9'
        }
      }
    }
    Min: 1
  }

test Choice Question "[*]?"
  MatchChoice {
    Matches: []TextMatch {
      RuneMatch {
        Filters: []RuneFilter {
          RuneFilter {
            Min: '*'
            Max: '*'
          }
        }
      }
      MatchSequence {
        Matches: []TextMatch{}
      }
    }
  }

test Choice Complex "[a]([b]|[c])|[d]"
  MatchChoice {
    Matches: []TextMatch {
      MatchSequence {
        Matches: []TextMatch{
          RuneMatch {
            Filters: []RuneFilter {
              RuneFilter {
                Min: 'a'
                Max: 'a'
               }
            }
          }
          MatchChoice {
            Matches: []TextMatch {
              RuneMatch {
                Filters: []RuneFilter {
                  RuneFilter {
                    Min: 'b'
                    Max: 'b'
                  }
                }
              }
              RuneMatch {
                Filters: []RuneFilter {
                  RuneFilter {
                    Min: 'c'
                    Max: 'c'
                  }
                }
              }
            }
          }
        }
      }
      RuneMatch {
        Filters: []RuneFilter {
          RuneFilter {
            Min: 'd'
            Max: 'd'
          }
        }
      }
    }
  }
