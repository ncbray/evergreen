struct TextMatch {
}

struct RuneFilter {
  Min rune
  Max rune
}

struct RuneMatch implements TextMatch {
  Filters []RuneFilter
}

struct MatchSequence implements TextMatch {
  Matches []TextMatch
}

struct MatchChoice implements TextMatch {
  Matches []TextMatch
}

struct MatchRepeat implements TextMatch {
  Match TextMatch
  Min int
}

struct Token {
}

struct IdTok implements Token {
  Text string
}

struct IntTok implements Token {
  Text string
  Value int
}

struct StrTok implements Token {
  Text string
  Value string
}

struct RuneTok implements Token {
  Text string
  Value rune
}

func S () {
  star {
    define c read;
    if ne c ' ' {
      if ne c '\t' {
        if ne c '\r' {
          if ne c '\n' {
            fail;
          }
        }
      }
    }
  }
}

func Alpha () {
  define c read;
  if ge c 'a' {
    if le c 'z' {
      return ();
    }
  }
  if ge c 'A' {
    if le c 'Z' {
      return ();
    }
  }
  if eq c '_' {
    return ();
  }
  fail;
}

func AlphaNum () {
  define c read;
  if ge c 'a' {
    if le c 'z' {
      return ();
    }
  }
  if ge c 'A' {
    if le c 'Z' {
      return ();
    }
  }
  if ge c '0' {
    if le c '9' {
      return ();
    }
  }
  if eq c '_' {
    return ();
  }
  fail;
}


func Ident (IdTok) {
  define text slice {
    call Alpha;
    star {
      call AlphaNum;
    }
  }
  call S;
  return (cons IdTok(Text: text));
}

func Int (IntTok) {
  define text slice {
    plus {
      define c read;
      if lt c '0' {
        fail;
      }
      if gt c '9' {
        fail;
      }
    }
  }
  call S;
  return (cons IntTok(Text: text))
}

func StrT (StrTok) {
  define text slice {
    define c read;
    if ne c '"' {
      fail;
    }
    star {
      assign c read;
      if eq c '\\' {
        read;
      }
      if eq c '"' {
        fail;
      }
    }
    assign c read;
    if ne c '"' {
      fail;
    }
  }
  call S;
  return (cons StrTok(Text: text))
}

func Rune (RuneTok) {
  define text slice {
    define c read;
    if ne c '\'' {
      fail;
    }
    assign c read;
    if eq c '\\' {
      read;
    }
    assign c read;
    if ne c '\'' {
      fail;
    }
  }
  call S;
  return (cons RuneTok(Text: text))
}

func MatchExpr (TextMatch) {
  define c read;
  if ne c '/' {
    fail;
  }
  call S;

  define e call Choice;

  assign c read;
  if ne c '/' {
    fail;
  }
  call S;

  return (e);
}

test Ident Alpha "a_B_c "
  IdTok{Text: "a_B_c"}

test Ident AlphaNum "a_1_7  "
  IdTok{Text: "a_1_7"}

test Int Num "1234567890  "
  IntTok{Text: "1234567890"}

test StrT Str "\"hello, world\"  "
  StrTok{Text: "\"hello, world\""}

test Rune Rune "'a'  "
  RuneTok{Text: "'a'"}


func ParseRuneFilterRune (rune) {
  define c read;
  if eq c ']' {
    fail;
  }
  if eq c '-' {
    fail;
  }
  return (c);
}

func ParseRuneFilter (RuneFilter) {
  define min call ParseRuneFilterRune;
  define max min;
  question {
    define c read;
    if ne c '-' {
      fail;
    }
    assign max call ParseRuneFilterRune;
  }
  return (cons RuneFilter(Min: min Max: max));
}

func MatchRune (RuneMatch) {
  define c read;
  if ne c '[' {
    fail;
  }
  define filters conl []RuneFilter()
  star {
    append filters call ParseRuneFilter;
  }
  if ne read ']' {
    fail;
  }
  call S;
  return (cons RuneMatch(Filters: filters))
}

func Atom (TextMatch) {
  question {
    return (call MatchRune);
  }
  define c read;
  if eq c '(' {
    define e call Choice;
    assign c read;
    if eq c ')' {
      return (e);
    }
  }
  fail;
}

func Postfix (TextMatch) {
  define e call Atom;
  question {
    define c read;
    if eq c '*' {
      call S;
      return (cons MatchRepeat(Match: e Min: 0));
    }
    if eq c '+' {
      call S;
      return (cons MatchRepeat(Match: e Min: 1));
    }
    if eq c '?' {
      call S;
      return (cons MatchChoice(Matches: conl []TextMatch(e cons MatchSequence(Matches: conl []TextMatch()))));
    }
    fail;
  }
  return (e);
}

func Sequence (TextMatch) {
  var e TextMatch = call Postfix;
  question {
    define l conl []TextMatch(e)
    plus {
      append l call Postfix;
    }
    assign e cons MatchSequence(Matches: l)
  }
  return (e)
}

func Choice (TextMatch) {
  var e TextMatch = call Sequence;
  question {
    define l conl []TextMatch(e)
    plus {
      define c read;
      if ne c '|' {
        fail;
      }
      call S;
      append l call Sequence;
    }
    assign e cons MatchChoice(Matches: l)
  }
  return (e)
}


test Choice One "[pq]"
  RuneMatch {
    Filters: []RuneFilter {
      RuneFilter {
        Min: 'p'
        Max: 'p'
      }
      RuneFilter {
        Min: 'q'
        Max: 'q'
      }
    }
  }

test Choice Three "[a][b][c]"
  MatchSequence {
    Matches: []TextMatch {
      RuneMatch {
        Filters: []RuneFilter {
          RuneFilter {
            Min: 'a'
            Max: 'a'
          }
        }
      }
      RuneMatch {
        Filters: []RuneFilter {
          RuneFilter {
            Min: 'b'
            Max: 'b'
          }
        }
      }
      RuneMatch {
        Filters: []RuneFilter {
          RuneFilter {
            Min: 'c'
            Max: 'c'
          }
        }
      }
    }
  }

test Choice Repeat "[0-9] + "
  MatchRepeat {
    Match: RuneMatch {
      Filters: []RuneFilter {
        RuneFilter {
          Min: '0'
          Max: '9'
        }
      }
    }
    Min: 1
  }

test Choice Question "[*]?"
  MatchChoice {
    Matches: []TextMatch {
      RuneMatch {
        Filters: []RuneFilter {
          RuneFilter {
            Min: '*'
            Max: '*'
          }
        }
      }
      MatchSequence {
        Matches: []TextMatch{}
      }
    }
  }

test Choice Complex "[a]([b]|[c])|[d]"
  MatchChoice {
    Matches: []TextMatch {
      MatchSequence {
        Matches: []TextMatch{
          RuneMatch {
            Filters: []RuneFilter {
              RuneFilter {
                Min: 'a'
                Max: 'a'
               }
            }
          }
          MatchChoice {
            Matches: []TextMatch {
              RuneMatch {
                Filters: []RuneFilter {
                  RuneFilter {
                    Min: 'b'
                    Max: 'b'
                  }
                }
              }
              RuneMatch {
                Filters: []RuneFilter {
                  RuneFilter {
                    Min: 'c'
                    Max: 'c'
                  }
                }
              }
            }
          }
        }
      }
      RuneMatch {
        Filters: []RuneFilter {
          RuneFilter {
            Min: 'd'
            Max: 'd'
          }
        }
      }
    }
  }
