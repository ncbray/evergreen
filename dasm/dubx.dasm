struct TextMatch {
}

struct RuneFilter {
  Min rune
  Max rune
}

struct RuneMatch implements TextMatch {
  Filters []RuneFilter
}

struct MatchSequence implements TextMatch {
  Matches []TextMatch
}

func S () {
  star {
    define c read;
    if ne c ' ' {
      if ne c '\t' {
        if ne c '\r' {
          if ne c '\n' {
            fail;
          }
        }
      }
    }
  }
}

func ParseRuneFilterRune (rune) {
  define c read;
  if eq c ']' {
    fail;
  }
  if eq c '-' {
    fail;
  }
  // TODO unescape
  return (c);
}

func ParseRuneFilter (RuneFilter) {
  define min call ParseRuneFilterRune;
  define max min;
  question {
    define c read;
    if ne c '-' {
      fail;
    }
    assign max call ParseRuneFilterRune;
  }
  return (cons RuneFilter(Min: min Max: max));
}

func MatchRune (RuneMatch) {
  define c read;
  if ne c '[' {
    fail;
  }
  define filters conl []RuneFilter()
  star {
    append filters call ParseRuneFilter;
  }
  if ne read ']' {
    fail;
  }
  call S;
  return (cons RuneMatch(Filters: filters))
}

func Sequence (TextMatch) {
  var e TextMatch = call MatchRune;
  question {
    define l conl []TextMatch(e)
    plus {
      append l call MatchRune;
    }
    assign e cons MatchSequence(Matches: l)
  }
  return (e)
}


test Sequence One "[pq]"
  RuneMatch {
    Filters: []RuneFilter {
      RuneFilter {
        Min: 'p'
        Max: 'p'
      }
      RuneFilter {
        Min: 'q'
        Max: 'q'
      }
    }
  }

test Sequence Three "[a][b][c]"
  MatchSequence {
    Matches: []TextMatch {
      RuneMatch {
        Filters: []RuneFilter {
          RuneFilter {
            Min: 'a'
            Max: 'a'
          }
        }
      }
      RuneMatch {
        Filters: []RuneFilter {
          RuneFilter {
            Min: 'b'
            Max: 'b'
          }
        }
      }
      RuneMatch {
        Filters: []RuneFilter {
          RuneFilter {
            Min: 'c'
            Max: 'c'
          }
        }
      }
    }
  }
